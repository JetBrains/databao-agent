import json
from hashlib import sha256
from pathlib import Path

from portus.core.data_source import DataSource, SemanticDict
from portus.data.configs.data_source_config import DataSourceConfig
from portus.data.configs.schema_inspection_config import InspectionOptions, SchemaInspectionConfig
from portus.data.database_schema_types import DatabaseSchema


def get_semantic_hash(
    semantic: SemanticDict, inspection_options: InspectionOptions, block_tables: list[str] | None = None
) -> str:
    sem_str = json.dumps(semantic, sort_keys=True)
    options_str = json.dumps(inspection_options.model_dump_for_cache(), sort_keys=True)
    block_str = str(sorted(block_tables or []))
    hash_ = sha256((sem_str + block_str + options_str).encode())
    return hash_.hexdigest()


async def generate_db_schema_cached(
    data_source: DataSource[DataSourceConfig],
    inspection_options: InspectionOptions,
    semantic_dict: SemanticDict,
    cache_prefix: str | None = None,
    cache_dir: Path | None = None,
    force_update_final_results_cache: bool = False,
) -> DatabaseSchema:
    if cache_dir is not None:
        assert cache_prefix is not None
        cache_file = cache_dir / f"{cache_prefix}__schema.json"
        version_file = cache_dir / f"{cache_prefix}__version.txt"
        # TODO: column contents (their stats) may change - semantic dict does not hold such info: improve cache key
        current_version_hash = get_semantic_hash(semantic_dict, inspection_options)
        if cache_file.is_file() and version_file.is_file() and not force_update_final_results_cache:
            cached_version_hash = version_file.read_text()
            if cached_version_hash == current_version_hash:
                return DatabaseSchema.model_validate_json(cache_file.read_text())
        db_schema = await data_source.inspect_schema(semantic_dict, inspection_options)

        cache_dir.mkdir(parents=True, exist_ok=True)
        cache_file.write_text(db_schema.model_dump_json(indent=2))
        version_file.write_text(current_version_hash)

        return db_schema
    return await data_source.inspect_schema(semantic_dict, inspection_options)


async def get_db_schema(
    data_source: DataSource[DataSourceConfig],
    inspection_config: SchemaInspectionConfig,
) -> DatabaseSchema:
    """
    Construct a DatabaseSchema object using the database metadata (e.g., as extracted from metabase, for
    the MetabaseSource; or stored in a manifest.json file generated by the`dbt docs generate` command).
    """
    data_source_hash = sha256(data_source.name.encode()).hexdigest()[:16]
    db_dir = Path(f"databases/{data_source_hash}")
    cache_dir = db_dir / "cache" if inspection_config.cache_final_results else None
    cache_prefix = "full"  # Used to be based on the dbt inspection tags
    semantic_dict: SemanticDict = "full"
    return await generate_db_schema_cached(
        data_source,
        inspection_config.inspection_options,
        semantic_dict=semantic_dict,
        cache_prefix=cache_prefix,
        cache_dir=cache_dir,
        force_update_final_results_cache=inspection_config.force_update_final_results_cache,
    )
